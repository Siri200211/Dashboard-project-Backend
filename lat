const express = require("express");
const mongoose = require("mongoose");
const csvParser = require("csv-parser");
const cors = require("cors");
const bodyParser = require("body-parser");
const moment = require("moment"); // Import moment.js for date parsing
const multer = require("multer"); // Import multer for handling file uploads
require("dotenv").config(); // Load environment variables from .env file
//sirimanne
const app = express();
app.use(cors());

// Increase JSON body parsing limit to handle large payloads
app.use(bodyParser.json({ limit: "50mb" }));
app.use(bodyParser.urlencoded({ limit: "50mb", extended: true }));

// Setup multer to handle file uploads
const storage = multer.memoryStorage(); // Store the file in memory
const upload = multer({
  storage: storage,
  limits: { fileSize: 50 * 1024 * 1024 }, // 50MB max file size
}); // Create the multer upload instance

// MongoDB connection
mongoose
  .connect(process.env.MONGODB_URI, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("MongoDB connected successfully");
  })
  .catch((err) => {
    console.error("MongoDB connection error:", err);
  });

// Order schema
const orderSchema = new mongoose.Schema({
  rto_split: String,
  category: String,
  date: Date,
  month: Number, // Add a field to store the month
  oss_service_order_type: String,
  order_type: String,
  order_sub_type: String,
  order_line_oss_service_type: String,
});

const Order = mongoose.model("Order", orderSchema);

const disconnectionSchema = new mongoose.Schema({
  order_line_rto_area: String,
  churn_date: Date, // Date of Churn
  account_num: String,
  activated_date: Date, // Date of Activation
  order_line_oss_service_type: String,
  bss_tariff_name: String,
  deleted_method: String,
  customer_type: String,
});

const Disconnection = mongoose.model("Disconnection", disconnectionSchema);

// Endpoint to upload CSV

app.post(
  "/upload-csv",
  upload.single("sales_details_2024"),
  async (req, res) => {
    const replaceData = req.query.replaceData === "true"; // Check if full replace is requested

    if (!req.file) {
      return res.status(400).send("No file uploaded");
    }

    const results = [];

    // Parse CSV from memory (Buffer)
    const csvData = req.file.buffer.toString(); // Convert buffer to string
    const readableStream = require("stream").Readable.from(csvData);

    readableStream
      .pipe(csvParser())
      .on("data", (data) => {
        // Use moment.js to parse the date string correctly and extract the month
        const parsedDate = moment(data.date, "MMMM D, YYYY").utc().toDate(); // Parse the date
        const month = parsedDate.getMonth(); // Extract the month (0-based index)

        results.push({
          rto_split: data.Rto_Split, // Mapping 'Rto Split' column from CSV
          category: data.Category,
          date: parsedDate, // Store the full Date object
          month: month, // Store the month as a number (0-11)
          oss_service_order_type: data["Oss Service Order Type"],
          order_type: data["Order Type"],
          order_sub_type: data["Order Sub Type"],
          order_line_oss_service_type: data["Order Line Oss Service Type"],
        });
      })
      .on("end", async () => {
        try {
          if (replaceData) {
            // Delete all existing records before inserting new ones (Full Replace)
            await Order.deleteMany({});
          } else {
            // Only insert data after the last saved date
            const lastSavedDate = await Order.findOne()
              .sort({ date: -1 })
              .select("date"); // Get the most recent date
            const lastSaved = lastSavedDate ? lastSavedDate.date : new Date(0); // Default to Unix epoch if no data

            // Filter new data to insert only records after the last saved date
            const newData = results.filter((item) =>
              moment(item.date).isAfter(lastSaved)
            );

            if (newData.length > 0) {
              await Order.insertMany(newData);
            } else {
              res.send("No new data to insert.");
              return;
            }
          }

          res.send("CSV data uploaded successfully");
        } catch (err) {
          console.error("Error uploading CSV data:", err);
          res.status(500).send("Error uploading CSV data");
        }
      });
  }
);

app.post(
  "/upload-disconnection-csv",
  upload.single("disconnection_file"),
  async (req, res) => {
    const replaceData = req.query.replaceData === "true"; // Check if full replace is requested

    if (!req.file) {
      return res.status(400).send("No file uploaded.");
    }

    const results = [];

    try {
      const csvData = req.file.buffer.toString(); // Convert buffer to string
      const readableStream = require("stream").Readable.from(csvData);

      readableStream
        .pipe(
          csvParser({
            mapHeaders: ({ header }) => header.trim(), // Trim spaces around headers
          })
        )
        .on("data", (data) => {
          try {
            let churnDate;
            let activatedDate;

            // First, try parsing with 4-digit year format
            let momentChurnDate = moment.utc(
              data["Churn_Date"],
              "MMMM D, YYYY",
              true
            );
            let momentActivatedDate = moment.utc(
              data["Activated_Date"],
              "MMMM D, YYYY",
              true
            );

            // If 4-digit parsing fails, try parsing with 2-digit year format
            if (!momentChurnDate.isValid()) {
              momentChurnDate = moment.utc(
                data["Churn_Date"],
                "MMMM D, YY",
                true
              );
            }
            if (!momentActivatedDate.isValid()) {
              momentActivatedDate = moment.utc(
                data["Activated_Date"],
                "MMMM D, YY",
                true
              );
            }

            // Skip rows with invalid dates
            if (!momentChurnDate.isValid()) {
              console.warn(
                `Invalid Churn_Date: '${data["Churn_Date"]}' - Skipping row.`
              );
              return;
            }
            if (!momentActivatedDate.isValid()) {
              console.warn(
                `Invalid Activated_Date: '${data["Activated_Date"]}' - Skipping row.`
              );
              return;
            }

            churnDate = momentChurnDate.toDate();
            activatedDate = momentActivatedDate.toDate();

            // Push parsed and valid data to results array
            results.push({
              order_line_rto_area: data["ORDER_LINE_RTO_AREA"],
              churn_date: churnDate,
              account_num: data["ACCOUNT_NUM"],
              activated_date: activatedDate,
              order_line_oss_service_type: data["ORDER_LINE_OSS_SERVICE_TYPE"],
              bss_tariff_name: data["BSS_TARIFF_NAME"],
              deleted_method: data["Deleted_method"],
              customer_type: data["CUSTOMER_TYPE"],
            });
          } catch (parseError) {
            console.error(
              "Error parsing row:",
              parseError.message,
              "Row:",
              data
            );
          }
        })
        .on("end", async () => {
          try {
            console.log(`Total valid rows processed: ${results.length}`);

            if (replaceData) {
              console.log("Replacing all existing disconnection records...");
              await Disconnection.deleteMany({});
              await Disconnection.insertMany(results);
              return res.send("Disconnection data replaced successfully.");
            } else {
              console.log("Performing incremental insertion...");
              try {
                // Fetch the most recent churn_date from the database
                const lastSaved = await Disconnection.findOne()
                  .sort({ churn_date: -1 }) // Sort in descending order to get the latest record
                  .select("churn_date"); // Retrieve only the churn_date field

                const lastSavedDate = lastSaved
                  ? lastSaved.churn_date
                  : new Date(0); // Default to epoch if no records

                console.log("Last saved churn date in the database:", lastSavedDate);

                // Filter results: only include rows with churn_date after lastSavedDate
                const newData = results.filter((item) =>
                  moment(item.churn_date).isAfter(lastSavedDate)
                );

                if (newData.length > 0) {
                  console.log(`Inserting ${newData.length} new records...`);
                  await Disconnection.insertMany(newData); // Insert filtered data
                  return res.send(
                    "New disconnection records inserted successfully."
                  );
                } else {
                  console.log("No new records to insert. All data is up-to-date.");
                  return res.send("No new disconnection data to insert.");
                }
              } catch (dbError) {
                console.error(
                  "Database error during incremental insertion:",
                  dbError.message
                );
                return res
                  .status(500)
                  .send(
                    "Error checking or saving disconnection data to the database."
                  );
              }
            }
          } catch (dbError) {
            console.error("Database error:", dbError.message);
            res
              .status(500)
              .send("Error saving disconnection data to the database.");
          }
        });
    } catch (error) {
      console.error("Error processing CSV file:", error.message);
      res.status(500).send("Error processing the uploaded file.");
    }
  }
);

// Aggregation endpoint for counts grouped by category, oss_service_order_type, and month
app.get("/get-counts", async (req, res) => {
  const { year, month, day } = req.query; // Extract filters from query params

  const matchStage = {};

  // Apply year filter
  if (year) {
    matchStage["$expr"] = { $eq: [{ $year: "$date" }, Number(year)] };
  }

  // Apply month filter (if provided)
  if (month && month !== "all") {
    matchStage["$expr"] = {
      ...matchStage["$expr"],
      $and: [
        ...(matchStage["$expr"]?.$and || []),
        { $eq: [{ $month: "$date" }, Number(month)] },
      ],
    };
  }

  // Apply day filter (if provided)
  if (day && day !== "all") {
    matchStage["$expr"] = {
      ...matchStage["$expr"],
      $and: [
        ...(matchStage["$expr"]?.$and || []),
        { $eq: [{ $dayOfMonth: "$date" }, Number(day)] },
      ],
    };
  }

  try {
    const counts = await Order.aggregate([
      { $match: matchStage }, // Apply date filters
      {
        $project: {
          category: 1,
          oss_service_order_type: 1,
          year: { $year: "$date" },
          month: { $month: "$date" },
          day: { $dayOfMonth: "$date" },
          order_line_oss_service_type: 1,
        },
      },
      {
        $group: {
          _id: {
            category: "$category",
            oss_service_order_type: "$oss_service_order_type",
            year: "$year",
            month: "$month",
            day: "$day",
            order_line_oss_service_type: "$order_line_oss_service_type",
          },
          count: { $sum: 1 },
        },
      },
      { $sort: { "_id.year": 1, "_id.month": 1, "_id.day": 1 } }, // Sort by year, month, day
    ]);

    res.json(counts); // Return the aggregated counts
  } catch (err) {
    console.error("Error fetching counts:", err);
    res.status(500).send("Error fetching counts");
  }
});
// ==========================================
//   BACKEND CODE WITH DURATION FILTER ADDED
// ==========================================

const getCategorizedCounts = async (filters = {}) => {
  const {
    year,
    month,
    day,
    order_line_rto_area,
    deleted_method,
    dgm,
    gm,
    // 1) Accept the duration filter here:
    duration,
  } = filters;

  // Static mapping for ORDER_LINE_RTO_AREA to DGM and GM
  const mapping = {
    "RTO - AD": { DGM: "NP", GM: "REGION 3" },
  "RTO - AG": { DGM: "WPS", GM: "REGION 2" },
  "RTO - AP": { DGM: "EP", GM: "REGION 3" },
  "RTO - BC": { DGM: "EP", GM: "REGION 3" },
  "RTO - BD": { DGM: "SAB & UVA", GM: "REGION 2" },
  "RTO - BW": { DGM: "SAB & UVA", GM: "REGION 2" },
  "RTO - CW": { DGM: "NWP", GM: "REGION 1" },
  "RTO - GL": { DGM: "SP", GM: "REGION 2" },
  "RTO - GP": { DGM: "CP", GM: "REGION 1" },
  "RTO - GQ": { DGM: "WPN", GM: "REGION 1" },
  "RTO - HB": { DGM: "SP", GM: "REGION 2" },
  "RTO - HK": { DGM: "METRO 1", GM: "METRO" },
  "RTO - HO": { DGM: "METRO 2", GM: "METRO" },
  "RTO - HR": { DGM: "WPS", GM: "REGION 2" },
  "RTO - HT": { DGM: "CP", GM: "REGION 1" },
  "RTO - JA": { DGM: "NP", GM: "REGION 3" },
  "RTO - KE": { DGM: "SAB & UVA", GM: "REGION 2" },
  "RTO - KG": { DGM: "NWP", GM: "REGION 1" },
  "RTO - KI": { DGM: "WPN", GM: "REGION 1" },
  "RTO - KL": { DGM: "EP", GM: "REGION 3" },
  "RTO - KLY": { DGM: "NWP", GM: "REGION 1" },
  "RTO - KO": { DGM: "NP", GM: "REGION 3" },
  "RTO - KON": { DGM: "METRO 1", GM: "METRO" },
  "RTO - KT": { DGM: "WPS", GM: "REGION 2" },
  "RTO - KX": { DGM: "METRO 1", GM: "METRO" },
  "RTO - KY": { DGM: "CP", GM: "REGION 1" },
  "RTO - MB": { DGM: "NP", GM: "REGION 3" },
  "RTO - MD": { DGM: "METRO 1", GM: "METRO" },
  "RTO - MH": { DGM: "SP", GM: "REGION 2" },
  "RTO - MLT": { DGM: "NP", GM: "REGION 2" },
  "RTO - MRG": { DGM: "SAB & UVA", GM: "REGION 2" },
  "RTO - MT": { DGM: "CP", GM: "REGION 1" },
  "RTO - ND": { DGM: "METRO 2", GM: "METRO" },
  "RTO - NG": { DGM: "WPN", GM: "REGION 1" },
  "RTO - NTB": { DGM: "WPN", GM: "REGION 1" },
  "RTO - NW": { DGM: "CP", GM: "REGION 1" },
  "RTO - PH": { DGM: "WPS", GM: "REGION 2" },
  "RTO - PR": { DGM: "EP", GM: "REGION 3" },
  "RTO - RM": { DGM: "METRO 2", GM: "METRO" },
  "RTO - RN": { DGM: "SAB & UVA", GM: "REGION 2" },
  "RTO - TC": { DGM: "EP", GM: "REGION 3" },
  "RTO - VA": { DGM: "NP", GM: "REGION 3" },
  "RTO - WT": { DGM: "WPN", GM: "REGION 1" },
  "RTO - YK": { DGM: "METRO 2", GM: "METRO" },
  };

  // 2) Define duration filter conditions (do NOT remove or change your existing code):
  const durationFilters = {
    "below 1 year": { $lt: ["$durationInYears", 1] },
    "1 year to 2 years": {
      $and: [{ $gte: ["$durationInYears", 1] }, { $lt: ["$durationInYears", 2] }],
    },
    "2 years to 3 years": {
      $and: [{ $gte: ["$durationInYears", 2] }, { $lt: ["$durationInYears", 3] }],
    },
    "3 years to 4 years": {
      $and: [{ $gte: ["$durationInYears", 3] }, { $lt: ["$durationInYears", 4] }],
    },
    "4 years to 5 years": {
      $and: [{ $gte: ["$durationInYears", 4] }, { $lt: ["$durationInYears", 5] }],
    },
    "more than 5 years": { $gte: ["$durationInYears", 5] },
  };

  const matchStage = { $and: [] };

  // Add global filters for order_line_rto_area
  if (order_line_rto_area) {
    matchStage.$and.push({ order_line_rto_area });
  }

  // Handle deleted_method filtering dynamically
  if (deleted_method) {
    if (deleted_method === "Customer Requested") {
      matchStage.$and.push({
        $or: [
          { deleted_method: "Customer Requested" },
          { deleted_method: "Promotion Upgrade" },
          { deleted_method: "Promotion Downgrade" },
        ],
      });
    } else {
      matchStage.$and.push({ deleted_method });
    }
  }

  // Add DGM and GM filtering
  if (dgm || gm) {
    matchStage.$and.push({
      $or: [
        dgm ? { DGM: dgm } : {},
        gm ? { GM: gm } : {},
      ],
    });
  }

  // Execute aggregation pipeline
  const results = await Disconnection.aggregate([
    // -------------------------------
    // Step 1: Apply global filters
    // -------------------------------
    { $match: matchStage.$and.length > 0 ? matchStage : {} },

    // -----------------------------------------------------------------
    // Step 2: Add DGM and GM fields using the mapping (NO CHANGES)
    // -----------------------------------------------------------------
    {
      $addFields: {
        DGM: {
          $let: {
            vars: {
              map: {
                $arrayElemAt: [
                  {
                    $filter: {
                      input: { $objectToArray: mapping },
                      as: "m",
                      cond: { $eq: ["$order_line_rto_area", "$$m.k"] },
                    },
                  },
                  0,
                ],
              },
            },
            in: "$$map.v.DGM",
          },
        },
        GM: {
          $let: {
            vars: {
              map: {
                $arrayElemAt: [
                  {
                    $filter: {
                      input: { $objectToArray: mapping },
                      as: "m",
                      cond: { $eq: ["$order_line_rto_area", "$$m.k"] },
                    },
                  },
                  0,
                ],
              },
            },
            in: "$$map.v.GM",
          },
        },
      },
    },

    // -----------------------------------------------
    // Step 3: Apply DGM and GM filters if provided
    // -----------------------------------------------
    {
      $match: {
        ...(dgm ? { DGM: dgm } : {}),
        ...(gm ? { GM: gm } : {}),
      },
    },

    // 3) Insert step: Add durationInYears for each record
    //    We do this BEFORE grouping, so each record has the field.
    {
      $addFields: {
        durationInYears: {
          $divide: [
            { $subtract: ["$churn_date", "$activated_date"] },
            1000 * 60 * 60 * 24 * 365,
          ],
        },
      },
    },

    // 4) Insert step: Match by duration filter ONLY if `duration` is provided
    ...(duration
      ? [
          {
            $match: {
              // Ensure we only apply this to E-IPTV records (as requested).
              $and: [
                // Only E-IPTV service types
                { order_line_oss_service_type: { $regex: /^E-IPTV/, $options: "i" } },
                // Apply the duration condition
                { $expr: durationFilters[duration] },
              ],
            },
          },
        ]
      : []),

    // --------------------------------------------
    // Step 4: Group records by ACCOUNT_NUM (unchanged)
    // --------------------------------------------
    {
      $group: {
        _id: "$account_num",
        records: { $push: "$$ROOT" }, // Collect all records for each ACCOUNT_NUM
      },
    },

    // -----------------------------------------------------
    // Step 5: Add fields for disconnection conditions
    // -----------------------------------------------------
    {
      $addFields: {
        hasCopperDisconnection: {
          $and: [
            { $in: ["AB-CAB", "$records.order_line_oss_service_type"] },
            { $in: ["E-IPTV COPPER", "$records.order_line_oss_service_type"] },
          ],
        },
        hasFiberDisconnection: {
          $and: [
            { $in: ["AB-FTTH", "$records.order_line_oss_service_type"] },
            { $in: ["E-IPTV FTTH", "$records.order_line_oss_service_type"] },
          ],
        },
        filteredRecords: {
          $filter: {
            input: "$records",
            as: "record",
            cond: {
              $and: [
                year ? { $eq: [{ $year: "$$record.churn_date" }, Number(year)] } : {},
                month ? { $eq: [{ $month: "$$record.churn_date" }, Number(month)] } : {},
                day ? { $eq: [{ $dayOfMonth: "$$record.churn_date" }, Number(day)] } : {},
              ],
            },
          },
        },
      },
    },

    // ---------------------------------------------------------
    // Step 6: Count disconnections based on conditions (unchanged)
    // ---------------------------------------------------------
    {
      $addFields: {
        categorizedCopper: {
          $cond: [
            "$hasCopperDisconnection",
            {
              $size: {
                $filter: {
                  input: "$filteredRecords",
                  as: "record",
                  cond: {
                    $and: [
                      { $eq: ["$$record.order_line_oss_service_type", "E-IPTV COPPER"] },
                      duration ? { $expr: durationFilters[duration] } : {}, // Apply duration filter
                    ],
                  },
                },
              },
            },
            0,
          ],
        },
        categorizedFiber: {
          $cond: [
            "$hasFiberDisconnection",
            {
              $size: {
                $filter: {
                  input: "$filteredRecords",
                  as: "record",
                  cond: {
                    $and: [
                      { $eq: ["$$record.order_line_oss_service_type", "E-IPTV FTTH"] },
                      duration ? { $expr: durationFilters[duration] } : {}, // Apply duration filter
                    ],
                  },
                },
              },
            },
            0,
          ],
        },
        categorizedOnlyPeotv: {
          $cond: [
            {
              $and: [
                { $not: "$hasCopperDisconnection" },
                { $not: "$hasFiberDisconnection" },
              ],
            },
            {
              $size: {
                $filter: {
                  input: "$filteredRecords",
                  as: "record",
                  cond: {
                    $and: [
                      {
                        $or: [
                          { $eq: ["$$record.order_line_oss_service_type", "E-IPTV COPPER"] },
                          { $eq: ["$$record.order_line_oss_service_type", "E-IPTV FTTH"] },
                        ],
                      },
                      duration ? { $expr: durationFilters[duration] } : {}, // Apply duration filter
                    ],
                  },
                },
              },
            },
            0,
          ],
        },
      }
    },

    // -----------------------------------------
    // Step 7: Summarize the counts (unchanged)
    // -----------------------------------------
    {
      $group: {
        _id: null,
        total_peotv_with_copper: { $sum: "$categorizedCopper" },
        total_peotv_with_fiber: { $sum: "$categorizedFiber" },
        total_only_peotv: { $sum: "$categorizedOnlyPeotv" },
      },
    },

    // -----------------------------------------
    // Step 8: Calculate the total (unchanged)
    // -----------------------------------------
    {
      $project: {
        total_peotv_with_copper: 1,
        total_peotv_with_fiber: 1,
        total_only_peotv: 1,
        total: {
          $add: [
            "$total_peotv_with_copper",
            "$total_peotv_with_fiber",
            "$total_only_peotv",
          ],
        },
      },
    },
  ]);

  return results[0] || {};
};

// =============================================================
//  ROUTE TO FETCH THE CATEGORIZED COUNTS WITH ALL FILTERS
// =============================================================
app.get("/disconnection-counts", async (req, res) => {
  try {
    // 5) Include the duration in query destructuring:
    const {
      year,
      month,
      day,
      order_line_rto_area,
      deleted_method,
      dgm,
      gm,
      duration, // NEW: add duration here
    } = req.query;

    const filters = {
      year,
      month,
      day,
      order_line_rto_area,
      deleted_method,
      dgm,
      gm,
      duration, // NEW: pass duration to filters
    };

    const counts = await getCategorizedCounts(filters);
    res.status(200).json(counts);
  } catch (error) {
    console.error("Error fetching categorized counts:", error.message);
    res.status(500).send("Error fetching disconnection counts.");
  }
});
app.get("/get-last-update", async (req, res) => {
  try {
    // Get the most recent churn_date from the database
    const lastUpdate = await Disconnection.findOne()
      .sort({ churn_date: -1 })  // Sort by churn_date in descending order
      .select("churn_date")  // Only select the churn_date field
      .exec();

    // If no data exists, return a default message
    if (!lastUpdate) {
      return res.json({ lastUpdated: "No data available" });
    }

    // Convert to a readable format (e.g., using Moment.js or native JS)
    const lastUpdatedDate = moment(lastUpdate.churn_date).format("MMMM D, YYYY");

    res.json({ lastUpdated: lastUpdatedDate });
  } catch (error) {
    console.error("Error fetching last updated date:", error);
    res.status(500).json({ error: "Failed to fetch last updated date" });
  }
});
// Endpoint to get the last updated date from the database
app.get("/get-last-updated", async (req, res) => {
    try {
      // Find the most recent order based on the date
      const lastUpdated = await Order.findOne()
        .sort({ date: -1 }) // Sort by date in descending order
        .select("date"); // Only select the date field
  
      if (lastUpdated) {
        // Send the most recent date as a response
        res.json({ lastUpdated: lastUpdated.date });
      } else {
        res.status(404).send("No data available.");
      }
    } catch (err) {
      console.error("Error fetching last updated date:", err);
      res.status(500).send("Error fetching last updated date.");
    }
  });


// Start the server
const PORT = process.env.PORT || 8070;
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
});








const getCategorizedCounts = async (filters = {}) => {
    const {
      year,
      month,
      day,
      order_line_rto_area,
      deleted_method,
      dgm,
      gm,
      duration,
    } = filters;
  
    // Static mapping for ORDER_LINE_RTO_AREA to DGM and GM
    const mapping = {
    "RTO - AD": { DGM: "NP", GM: "REGION 3" },
    "RTO - AG": { DGM: "WPS", GM: "REGION 2" },
    "RTO - AP": { DGM: "EP", GM: "REGION 3" },
    "RTO - BC": { DGM: "EP", GM: "REGION 3" },
   
    };
  
    // 2) Define duration filter conditions (do NOT remove or change your existing code):
    const durationFilters = {
      "below 1 year": { $lt: ["$durationInYears", 1] },
      "1 year to 2 years": { $and: [{ $gte: ["$durationInYears", 1] }, { $lt: ["$durationInYears", 2] }] },
      "2 years to 3 years": { $and: [{ $gte: ["$durationInYears", 2] }, { $lt: ["$durationInYears", 3] }] },
      "3 years to 4 years": { $and: [{ $gte: ["$durationInYears", 3] }, { $lt: ["$durationInYears", 4] }] },
      "4 years to 5 years": { $and: [{ $gte: ["$durationInYears", 4] }, { $lt: ["$durationInYears", 5] }] },
      "more than 5 years": { $gte: ["$durationInYears", 5] },
    };
  
  
    const matchStage = { $and: [] };
  
    // Add global filters for order_line_rto_area
    if (order_line_rto_area) {
      matchStage.$and.push({ order_line_rto_area });
    }
  
    // Handle deleted_method filtering dynamically
    if (deleted_method) {
      if (deleted_method === "Customer Requested") {
        matchStage.$and.push({
          $or: [
            { deleted_method: "Customer Requested" },
            { deleted_method: "Promotion Upgrade" },
            { deleted_method: "Promotion Downgrade" },
          ],
        });
      } else {
        matchStage.$and.push({ deleted_method });
      }
    }
  
    // Add DGM and GM filtering
    if (dgm || gm) {
      matchStage.$and.push({
        $or: [
          dgm ? { DGM: dgm } : {},
          gm ? { GM: gm } : {},
        ],
      });
    }
  
    // Execute aggregation pipeline
    const results = await Disconnection.aggregate([
      // -------------------------------
      // Step 1: Apply global filters
      // -------------------------------
      { $match: matchStage.$and.length > 0 ? matchStage : {} },
  
      // -----------------------------------------------------------------
      // Step 2: Add DGM and GM fields using the mapping (NO CHANGES)
      // -----------------------------------------------------------------
      {
        $addFields: {
          DGM: {
            $let: {
              vars: {
                map: {
                  $arrayElemAt: [
                    {
                      $filter: {
                        input: { $objectToArray: mapping },
                        as: "m",
                        cond: { $eq: ["$order_line_rto_area", "$$m.k"] },
                      },
                    },
                    0,
                  ],
                },
              },
              in: "$$map.v.DGM",
            },
          },
          GM: {
            $let: {
              vars: {
                map: {
                  $arrayElemAt: [
                    {
                      $filter: {
                        input: { $objectToArray: mapping },
                        as: "m",
                        cond: { $eq: ["$order_line_rto_area", "$$m.k"] },
                      },
                    },
                    0,
                  ],
                },
              },
              in: "$$map.v.GM",
            },
          },
        },
      },
  
      // -----------------------------------------------
      // Step 3: Apply DGM and GM filters if provided
      // -----------------------------------------------
      {
        $match: {
          ...(dgm ? { DGM: dgm } : {}),
          ...(gm ? { GM: gm } : {}),
        },
      },
  
      // 3) Insert step: Add durationInYears for each record
      //    We do this BEFORE grouping, so each record has the field.
      {
        
          $addFields: {
            durationInYears: {
              $divide: [{ $subtract: ["$churn_date", "$activated_date"] }, 1000 * 60 * 60 * 24 * 365],
            },
          },
        },
    
  
      // 4) Insert step: Match by duration filter ONLY if `duration` is provided
      ...(duration
        ? [
            {
              $match: {
                $expr: durationFilters[duration],
              },
            },
          ]
        : []),
      // --------------------------------------------
      // Step 4: Group records by ACCOUNT_NUM (unchanged)
      // --------------------------------------------
      {
        $group: {
          _id: "$account_num",
          records: { $push: "$$ROOT" }, // Collect all records for each ACCOUNT_NUM
        },
      },
  
      // -----------------------------------------------------
      // Step 5: Add fields for disconnection conditions
      // -----------------------------------------------------
      {
        $addFields: {
          hasCopperDisconnection: {
            $and: [
              { $in: ["AB-CAB", "$records.order_line_oss_service_type"] },
              { $in: ["E-IPTV COPPER", "$records.order_line_oss_service_type"] },
            ],
          },
          hasFiberDisconnection: {
            $and: [
              { $in: ["AB-FTTH", "$records.order_line_oss_service_type"] },
              { $in: ["E-IPTV FTTH", "$records.order_line_oss_service_type"] },
            ],
          },
          filteredRecords: {
            $filter: {
              input: "$records",
              as: "record",
              cond: {
                $and: [
                  year ? { $eq: [{ $year: "$$record.churn_date" }, Number(year)] } : {},
                  month ? { $eq: [{ $month: "$$record.churn_date" }, Number(month)] } : {},
                  day ? { $eq: [{ $dayOfMonth: "$$record.churn_date" }, Number(day)] } : {},
                ],
              },
            },
          },
        },
      },
  
      // ---------------------------------------------------------
      // Step 6: Count disconnections based on conditions (unchanged)
      // ---------------------------------------------------------
      {
        $addFields: {
          categorizedCopper: {
            $cond: [
              "$hasCopperDisconnection",
              {
                $size: {
                  $filter: {
                    input: "$filteredRecords",
                    as: "record",
                    cond: {
                      $and: [
                        { $eq: ["$$record.order_line_oss_service_type", "E-IPTV COPPER"] },
                        duration ? { $expr: durationFilters[duration] } : {}, // Apply duration filter
                      ],
                    },
                  },
                },
              },
              0,
            ],
          },
          categorizedFiber: {
            $cond: [
              "$hasFiberDisconnection",
              {
                $size: {
                  $filter: {
                    input: "$filteredRecords",
                    as: "record",
                    cond: {
                      $and: [
                        { $eq: ["$$record.order_line_oss_service_type", "E-IPTV FTTH"] },
                        duration ? { $expr: durationFilters[duration] } : {}, // Apply duration filter
                      ],
                    },
                  },
                },
              },
              0,
            ],
          },
          categorizedOnlyPeotv: {
            $cond: [
              {
                $and: [
                  { $not: "$hasCopperDisconnection" },
                  { $not: "$hasFiberDisconnection" },
                ],
              },
              {
                $size: {
                  $filter: {
                    input: "$filteredRecords",
                    as: "record",
                    cond: {
                      $and: [
                        {
                          $or: [
                            { $eq: ["$$record.order_line_oss_service_type", "E-IPTV COPPER"] },
                            { $eq: ["$$record.order_line_oss_service_type", "E-IPTV FTTH"] },
                          ],
                        },
                        duration ? { $expr: durationFilters[duration] } : {}, // Apply duration filter
                      ],
                    },
                  },
                },
              },
              0,
            ],
          },
        }
      },
  
      // -----------------------------------------
      // Step 7: Summarize the counts (unchanged)
      // -----------------------------------------
      {
        $group: {
          _id: null,
          total_peotv_with_copper: { $sum: "$categorizedCopper" },
          total_peotv_with_fiber: { $sum: "$categorizedFiber" },
          total_only_peotv: { $sum: "$categorizedOnlyPeotv" },
        },
      },
  
      // -----------------------------------------
      // Step 8: Calculate the total (unchanged)
      // -----------------------------------------
      {
        $project: {
          total_peotv_with_copper: 1,
          total_peotv_with_fiber: 1,
          total_only_peotv: 1,
          total: {
            $add: [
              "$total_peotv_with_copper",
              "$total_peotv_with_fiber",
              "$total_only_peotv",
            ],
          },
        },
      },
    ]);
  
    return results[0] || {};
  };
  
  // =============================================================
  //  ROUTE TO FETCH THE CATEGORIZED COUNTS WITH ALL FILTERS
  // =============================================================
  app.get("/disconnection-counts", async (req, res) => {
    try {
      // 5) Include the duration in query destructuring:
      const {
        year,
        month,
        day,
        order_line_rto_area,
        deleted_method,
        dgm,
        gm,
        duration, // NEW: add duration here
      } = req.query;
  
      const filters = {
        year,
        month,
        day,
        order_line_rto_area,
        deleted_method,
        dgm,
        gm,
        duration, // NEW: pass duration to filters
      };
  
      const counts = await getCategorizedCounts(filters);
      res.status(200).json(counts);
    } catch (error) {
      console.error("Error fetching categorized counts:", error.message);
      res.status(500).send("Error fetching disconnection counts.");
    }
  });









  const getCategorizedCounts = async (filters = {}) => {
    const {
      year,
      month,
      day,
      order_line_rto_area,
      deleted_method,
      dgm,
      gm,
      duration,
    } = filters;
  
    // Static mapping for ORDER_LINE_RTO_AREA to DGM and GM
    const mapping = {
      "RTO - AD": { DGM: "NP", GM: "REGION 3" },
    "RTO - AG": { DGM: "WPS", GM: "REGION 2" },
    "RTO - AP": { DGM: "EP", GM: "REGION 3" },
  
    };
    
  
    // Define duration filter conditions
    const durationFilters = {
      "below 1 year": { $lt: ["$durationInYears", 1] },
      "1 year to 2 years": { $and: [{ $gte: ["$durationInYears", 1] }, { $lt: ["$durationInYears", 2] }] },
      "2 years to 3 years": { $and: [{ $gte: ["$durationInYears", 2] }, { $lt: ["$durationInYears", 3] }] },
      "3 years to 4 years": { $and: [{ $gte: ["$durationInYears", 3] }, { $lt: ["$durationInYears", 4] }] },
      "4 years to 5 years": { $and: [{ $gte: ["$durationInYears", 4] }, { $lt: ["$durationInYears", 5] }] },
      "more than 5 years": { $gte: ["$durationInYears", 5] },
    };
  
    const matchStage = { $and: [] };
  
    // Add global filters for order_line_rto_area
    if (order_line_rto_area) {
      matchStage.$and.push({ order_line_rto_area });
    }
  
    // Handle deleted_method filtering dynamically
    if (deleted_method) {
      if (deleted_method === "Customer Requested") {
        matchStage.$and.push({
          $or: [
            { deleted_method: "Customer Requested" },
            { deleted_method: "Promotion Upgrade" },
            { deleted_method: "Promotion Downgrade" },
          ],
        });
      } else {
        matchStage.$and.push({ deleted_method });
      }
    }
  
    // Add DGM and GM filtering
    if (dgm || gm) {
      matchStage.$and.push({
        $or: [
          dgm ? { DGM: dgm } : {},
          gm ? { GM: gm } : {},
        ],
      });
    }
  
    // Execute aggregation pipeline
    const results = await Disconnection.aggregate([
      // -------------------------------
      // Step 1: Apply global filters
      // -------------------------------
      { $match: matchStage.$and.length > 0 ? matchStage : {} },
  
      // -----------------------------------------------------------------
      // Step 2: Add DGM and GM fields using the mapping (NO CHANGES)
      // -----------------------------------------------------------------
      {
        $addFields: {
          DGM: {
            $let: {
              vars: {
                map: {
                  $arrayElemAt: [
                    {
                      $filter: {
                        input: { $objectToArray: mapping },
                        as: "m",
                        cond: { $eq: ["$order_line_rto_area", "$$m.k"] },
                      },
                    },
                    0,
                  ],
                },
              },
              in: "$$map.v.DGM",
            },
          },
          GM: {
            $let: {
              vars: {
                map: {
                  $arrayElemAt: [
                    {
                      $filter: {
                        input: { $objectToArray: mapping },
                        as: "m",
                        cond: { $eq: ["$order_line_rto_area", "$$m.k"] },
                      },
                    },
                    0,
                  ],
                },
              },
              in: "$$map.v.GM",
            },
          },
        },
      },
  
      // -----------------------------------------------
      // Step 3: Apply DGM and GM filters if provided
      // -----------------------------------------------
      {
        $match: {
          ...(dgm ? { DGM: dgm } : {}),
          ...(gm ? { GM: gm } : {}),
        },
      },
  
      // -----------------------------------------------
      // Step 4: Add durationInYears for each record
      // -----------------------------------------------
      {
        $addFields: {
          durationInYears: {
            $divide: [{ $subtract: ["$churn_date", "$activated_date"] }, 1000 * 60 * 60 * 24 * 365],
          },
        },
      },
  
      // Apply duration filter globally at this stage
      ...(duration
        ? [
            {
              $match: {
                $expr: {
                  $and: [durationFilters[duration]], // Wrapped in an array for correct $and usage
                },
              },
            },
          ]
        : []),
  
      // --------------------------------------------
      // Step 5: Group records by ACCOUNT_NUM (unchanged)
      // --------------------------------------------
      {
        $group: {
          _id: "$account_num",
          records: { $push: "$$ROOT" }, // Collect all records for each ACCOUNT_NUM
        },
      },
  
      // -----------------------------------------------------
      // Step 6: Add fields for disconnection conditions (unchanged)
      // -----------------------------------------------------
      {
        $addFields: {
          hasCopperDisconnection: {
            $and: [
              { $in: ["AB-CAB", "$records.order_line_oss_service_type"] },
              { $in: ["E-IPTV COPPER", "$records.order_line_oss_service_type"] },
            ],
          },
          hasFiberDisconnection: {
            $and: [
              { $in: ["AB-FTTH", "$records.order_line_oss_service_type"] },
              { $in: ["E-IPTV FTTH", "$records.order_line_oss_service_type"] },
            ],
          },
          filteredRecords: {
            $filter: {
              input: "$records",
              as: "record",
              cond: {
                $and: [
                  year ? { $eq: [{ $year: "$$record.churn_date" }, Number(year)] } : {},
                  month ? { $eq: [{ $month: "$$record.churn_date" }, Number(month)] } : {},
                  day ? { $eq: [{ $dayOfMonth: "$$record.churn_date" }, Number(day)] } : {},
                ],
              },
            },
          },
          eIptvRecords: {
            $filter: {
              input: "$records",
              as: "record",
              cond: {
                $regexMatch: {
                  input: "$$record.order_line_oss_service_type",
                  regex: /^E-IPTV/,
                  options: "i",
                },
              },
            },
          },
        },
      },
  
      // ---------------------------------------------------------
      // Step 7: Count disconnections based on conditions (unchanged)
      // ---------------------------------------------------------
      {
        $addFields: {
          categorizedCopper: {
            $cond: [
              "$hasCopperDisconnection",
              {
                $size: {
                  $filter: {
                    input: "$filteredRecords",
                    as: "record",
                    cond: {
                      $eq: ["$$record.order_line_oss_service_type", "E-IPTV COPPER"],
                    },
                  },
                },
              },
              0,
            ],
          },
          categorizedFiber: {
            $cond: [
              "$hasFiberDisconnection",
              {
                $size: {
                  $filter: {
                    input: "$filteredRecords",
                    as: "record",
                    cond: {
                      $eq: ["$$record.order_line_oss_service_type", "E-IPTV FTTH"],
                    },
                  },
                },
              },
              0,
            ],
          },
          categorizedOnlyPeotv: {
            $cond: [
              {
                $and: [
                  { $not: "$hasCopperDisconnection" },
                  { $not: "$hasFiberDisconnection" },
                ],
              },
              {
                $size: {
                  $filter: {
                    input: "$filteredRecords",
                    as: "record",
                    cond: {
                      $or: [
                        { $eq: ["$$record.order_line_oss_service_type", "E-IPTV COPPER"] },
                        { $eq: ["$$record.order_line_oss_service_type", "E-IPTV FTTH"] },
                      ],
                    },
                  },
                },
              },
              0,
            ],
          },
        },
      },
  
      // -----------------------------------------
      // Step 8: Summarize the counts (unchanged)
      // -----------------------------------------
      {
        $group: {
          _id: null,
          total_peotv_with_copper: { $sum: "$categorizedCopper" },
          total_peotv_with_fiber: { $sum: "$categorizedFiber" },
          total_only_peotv: { $sum: "$categorizedOnlyPeotv" },
        },
      },
  
      // -----------------------------------------
      // Step 9: Calculate the total (unchanged)
      // -----------------------------------------
      {
        $project: {
          _id: 0,
          total_peotv_with_copper: 1,
          total_peotv_with_fiber: 1,
          total_only_peotv: 1,
          total: {
            $add: [
              "$total_peotv_with_copper",
              "$total_peotv_with_fiber",
              "$total_only_peotv",
            ],
          },
        },
      },
    ]);
  
    return results[0] || {};
  };